# CI/CD Integration
This infrastructure is integrated with a Jenkins pipeline, which automates the execution of Terraform commands (init, plan, apply, destroy) for both DEV and PROD environments. This ensures consistent and repeatable infrastructure provisioning as part of the CI/CD process.

The Jenkins pipeline is configured to:

- Select the appropriate environment (DEV or PROD)

- Trigger Terraform initialization and apply based on Git commits or manual approvals

- Manage backend state securely with S3 and DynamoDB



# Terraform Multi-Environment Infrastructure Configuration

This repository contains a structured Terraform configuration for provisioning a multi-environment infrastructure in AWS. It includes separate configurations for `DEV` and `PROD` environments, using a module-based approach for better scalability and maintainability.

---

## Project Structure
```
terraform/
├── README.md
├── vpc.tf
├── bastion.tf
├── AWS-EKS.tf
├── RDS.tf
├── route53.tf
├── providers.tf
├── backend.tf
├── variables.tf
├── outputs.tf
├── environments/
│   ├── DEV/
│   │   ├── backend.tf
│   │   ├── dev.tfvars
│   └── PROD/
│       ├── backend.tf
│       ├── dev.tfvars
├── modules/
│   ├── VPC/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── outputs.tf
│   ├── AWS-RDS/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── outputs.tf
│   ├── AWS-EKS/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── outputs.tf
│   ├── ec2/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── outputs.tf
│   ├── key-pair/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── outputs.tf
│   ├── security-groups/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── outputs.tf
├── module-test/
│   ├── VPC/
│   ├── AWS-RDS/
│   ├── AWS-EKS/
│   ├── ec2/
│   ├── key-pair/
│   ├── security-groups/
```

---

## Components
### 1. **VPC**
- Configures the Virtual Private Cloud (VPC) with CIDR blocks and subnets.
- Supports both public and private subnets.
- Configures route tables and internet gateway.

### 2. **Bastion Host**
- Creates an EC2 instance as a bastion host.
- Uses a key pair generated by Terraform for SSH access.
- Attaches to public subnets for secure access to private resources.

### 3. **AWS RDS**
- Creates an RDS instance using MySQL engine.
- Configures parameter groups and subnet groups.
- Handles backup, maintenance window, and monitoring settings.

### 4. **EKS**
- Creates an EKS cluster.
- Configures node groups with scaling configurations.
- Supports SPOT and ON-DEMAND instances.

### 5. **Route53**
- Configures DNS records using Route53.
- Supports different record types (A, CNAME, etc.).

### 6. **Security Groups**
- Creates security groups for EC2, RDS, and EKS.
- Allows specific CIDR ranges for access control.

### 7. **Key Pair**
- Generates SSH key pairs using Terraform.
- Configures EC2 instances with the generated keys.

---

## Environment Configuration
Separate configurations for `DEV` and `PROD` environments are stored under `environments/` directory.

### **Example DEV Configuration**
`environments/DEV/dev.tfvars`
```hcl
environment = "dev"
project_name = "fusioniq"

# VPC
cidr_block = "10.0.0.0/16"
cidr_public = ["10.0.1.0/24","10.0.2.0/24"]
cidr_private = ["10.0.3.0/24","10.0.4.0/24"]
cidr_database = ["10.0.5.0/24","10.0.6.0/24"]

# Bastion
ec2_tags = {
  Name = "bastion-dev"
  project_name = "fusioniq"
  terraform = true
}

# RDS
rds_parameter_grp_name = "rds-parameter-group-dev"
allocated_storage = 20
storage_type = "gp2"
engine = "mysql"
engine_version = "8.0.41"
instance_class = "db.t3.micro"
identifier = "fusioniq"
db_name = "dev"
username = "admin"
manage_master_user_password = true
publicly_accessible = false
skip_final_snapshot = true

# EKS
node_groups = {
  general = {
    instance_types = ["t3.medium"]
    capacity_type  = "SPOT"
    node_group_name = "fusioniq-dev-node"
    scaling_config = {
      desired_size = 1
      max_size     = 2
      min_size     = 1
    }
  }
}

# Route53
zone_id = ""
name = ""
type = ""
ttl = 300
record = [""]
```

---

## Backend Configuration
Terraform state is stored in an S3 bucket, and DynamoDB is used for state locking.

**Example Backend Configuration (DEV)**
`environments/DEV/backend.tf`
```hcl
terraform {
  backend "s3" {
    bucket         = "fusioniq-project-dev"
    key            = "global/s3/terraform.tfstate"
    region         = "us-east-1"
    dynamodb_table = "fusioniq-tf-lock-dev"
  }
}
```

---

## How to Execute
### 1. **Initialize the Terraform Configuration**
For DEV environment:
```sh
terraform init -reconfigure -backend-config=environments/DEV/backend.tf
```
**Note**: for first time execution `-reconfigure` is not required

For PROD environment:
```sh
terraform init -reconfigure -backend-config=environments/PROD/backend.tf
```

### 2. **Apply Terraform Configuration**
For DEV environment:
```sh
terraform apply -var-file=environments/DEV/dev.tfvars
```
For PROD environment:
```sh
terraform apply -var-file=environments/PROD/prod.tfvars
```

### 3. **Destroy Terraform Configuration**
To destroy resources:
```sh
terraform destroy -var-file=environments/DEV/dev.tfvars
```

